
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=updateProduct_850f4057dd
ROOST_METHOD_SIG_HASH=updateProduct_850f4057dd

תסריט [1]: בדיקת עדכון מוצר קיים במאגר

פרטים:
  שםבדיקה: updateExistingProductSuccessfully
  תיאור: בדיקה לוודא שמוצר קיים במאגר מתעדכן בהצלחה כאשר כל הפרמטרים שהוזנו תקינים. הבדיקה מספקת ערכי מוצרים חדשים ובודקת האם הערכים המעודכנים שמורים כראוי.

ביצוע:
  סידור: צור מופע של Product קיים עם מזהה, והוסף אותו ל־mock של productRepository שידמה את מאגר הנתונים.
  פעולה: קרא למתודה updateProduct עם מזהה המוצר והמשאב החדש לעריכה.
  אישור: וודא שהמופע החדש אכן עודכן ושמור במאגר הנתונים באמצעות Assertions.

אימות:
  הבדיקה מאשרת שהמוצר מתעדכן כראוי באמצעות Mock של ProductRepository. תוצאה זו חשובה כדי לוודא שהיישום שלנו משנה את פרטי המוצר הנכונים לפי בקשת המשתמש.

*/

// ********RoostGPT********
package com.bootexample4.products.controller;

import com.bootexample4.products.model.Product;
import com.bootexample4.products.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.ResponseEntity;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

public class ProductControllerUpdateProductTest {

	@Mock
	private ProductRepository productRepository;

	@InjectMocks
	private ProductController productController;

	@BeforeEach
	public void setUp() {
		MockitoAnnotations.openMocks(this);
	}

	@Test
	@Tag("valid")
	public void updateExistingProductSuccessfully() {
		// Arrange
		Long productId = 1L;
		Product existingProduct = new Product();
		existingProduct.setId(productId);
		existingProduct.setName("Old Name");
		existingProduct.setDescription("Old Description");
		existingProduct.setPrice(100.0);
		Product updatedProduct = new Product();
		updatedProduct.setId(productId);
		updatedProduct.setName("New Name");
		updatedProduct.setDescription("New Description");
		updatedProduct.setPrice(150.0);
		when(productRepository.findById(productId)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenReturn(updatedProduct);
		// Act
		ResponseEntity<Product> response = productController.updateProduct(productId, updatedProduct);
		// Assert
		verify(productRepository).findById(productId);
		verify(productRepository).save(existingProduct);
		assertEquals(ResponseEntity.ok(updatedProduct), response);
	}

	@Test
	@Tag("invalid")
	public void updateNonExistentProduct() {
		// Arrange
		Long productId = 999L;
		Product updatedProduct = new Product();
		updatedProduct.setId(productId);
		updatedProduct.setName("New Name");
		updatedProduct.setDescription("New Description");
		updatedProduct.setPrice(150.0);
		when(productRepository.findById(productId)).thenReturn(Optional.empty());
		// Act
		ResponseEntity<Product> response = productController.updateProduct(productId, updatedProduct);
		// Assert
		verify(productRepository).findById(productId);
		verify(productRepository, never()).save(any(Product.class));
		assertEquals(ResponseEntity.notFound().build(), response);
	}

}